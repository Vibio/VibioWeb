<?php
function hbi_nodeapi(&$node, $op, $a3=null, $a4=null)
{
	if ($node->type != "vibio_item")
	{
		return;
	}
	
	switch ($op)
	{
		case "update":
			$u = user_load($node->uid);
			
			$args = array(
				"@user"			=> l($u->name, "user/{$u->uid}"),
				"@node_title"	=> l($node->title, "node/{$node->nid}"),
			);
			$params = array("heartbeat_edit_node", $node->uid, 0, $node->nid, 0, $args);
			break;
	}
}

function hbi_views_api()
{
	return array(
		"api"	=> 2,
	);
}

function hbi_user_relationships($op, &$relationship)
{
	switch ($op)
	{
		case "approve":
			_hbi_set_relationship($op, $relationship);
			break;
	}
}

function hbi_privacy_new_user($form, $account, $category)
{
	if ($category != "privacy_settings")
	{
		return;
	}
	
	$hidden_messages = _hbi_hidden_messages();
	
	$sql = "SELECT `message_id`
			FROM {heartbeat_messages}";
	$res = db_query($sql);
	
	while ($row = db_fetch_array($res))
	{
		$message_id = $row['message_id'];
		
		if (!in_array($message_id, $hidden_messages))
		{
			privacy_set($account->uid, "heartbeat_messages", $message_id, PRIVACY_PUBLIC);
		}
	}
}

function hbi_collections_insert($collection)
{
	$u = user_load($collection['uid']);
	
	$args = array(
		"@user"			=> l($u->name, "user/{$u->uid}"),
		"@collection"	=> l($collection['title'], "collections/{$collection['cid']}"),
	);
	
	heartbeat_api_log("heartbeat_add_collection", $u->uid, 0, $collection['cid'], 0, $args);
}

function hbi_privacy_update_user($form, $user, $category)
{
	if ($category == "privacy_settings" && !empty($form['heartbeat_activity_settings']))
	{
		foreach ($form['heartbeat_activity_settings'] as $type_id => $access)
		{
			privacy_set($user->uid, "heartbeat_messages", $type_id, $access['access']);
		}
	}
}

function hbi_offer2buy_make_offer($node, $offerer, $owner, $offer)
{
	$variables = array(
		"@offerer"	=> l($offerer->name, "user/{$offerer->uid}"),
		"@item"		=> l($node->title, "node/{$node->nid}"),
	);
	
	heartbeat_api_log("make_offer_on_vibio_item", $offerer->uid, $owner->uid, $node->nid, 0, $variables);
}

function _hbi_set_relationship($op, &$relationship)
{
	$message_id = $op == "approve" ? "heartbeat_become_friends" : "heartbeat_cancel_friendship";
	$variables = array(
		"@user1" 		=> l($relationship->requestee->name, "user/".$relationship->requestee->uid),
		"@relation_type"=> $relationship->name,
		"@user2"		=> l($relationship->requester->name, "user/".$relationship->requester->uid),
		"duplicate"		=> 1,
	);
	
	heartbeat_api_log($message_id, $relationship->requestee->uid, $relationship->requester->uid, 0, 0, $variables);
	
	$var_reverse = $variables;
	$var_reverse['@user1'] = $variables['@user2'];
	$var_reverse['@user2'] = $variables['@user1'];
	
	heartbeat_api_log($message_id, $relationship->requester->uid, $relationship->requestee->uid, 0, 0, $var_reverse);
}

function _hbi_hidden_messages()
{
	return array(
		"heartbeat_add_FL_OW_relation",
		"heartbeat_cancel_friendship",
		"heartbeat_edit_account",
	);
}

/*
 the last_resort param should be used for messages that should only get logged only if there are no other messages
 for nid. This is useful for node updating, where the messages "X is selling Y", "X bought Y", etc can be used in place
 of generic "X has just updated Y"
*/
function hbi_node_log_update_queue($nid=false, $hb_message_params=array(), $last_resort=false, $clear=false)
{
	static $message_queue = array();
	
	if ($nid)
	{
		if ($clear)
		{
			$message_queue[$nid] = array();
		}
		
		$message_queue[$nid][] = array(
			"message"		=> $hb_message_params,
			"last_resort"	=> $last_resort,
		);
	}
	
	return $message_queue;
}

//should be called on exit :\
function hbi_node_log_update()
{
	$message_queue = hbi_node_log_update_queue();
	foreach ($message_queue as $nid => $message_data)
	{
		if ($message_array['last_resort'] && count($message_data))
		{
			continue;
		}
		
		call_user_func_array("heartbeat_api_log", $message_data($message_data['message']));
	}
}
?>