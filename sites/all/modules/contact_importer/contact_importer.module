<?php
// $Id: contact_importer.module,v 1.1.4.16 2010/09/14 13:54:30 dalin Exp $

/**
 * @file
 * Contact Importer.
 *
 * Enables other modules to allow users to import email addresses from their address book.
 */

/**
 * @category HOOKS
 */

/**
 * Implementation of hook_perm.
 */
function contact_importer_perm() {
  return array('access contact importer', 'administer contact importer');
}

/**
 * Implementation of hook_menu.
 */
function contact_importer_menu() {
  $items = array();

  // Admin
  $items['admin/settings/contact_importer'] = array(
    'title' => 'Contact Importer',
    'page callback' => 'contact_importer_info',
    'access arguments' => array('administer contact importer'),
    'file' => 'contact_importer.admin.inc',
  );
  $items['admin/settings/contact_importer/info'] = array(
    'title' => 'Info',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -2,
  );
   $items['admin/settings/contact_importer/settings'] = array(
    'title' => 'Settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('contact_importer_settings_form'),
    'access arguments' => array('administer contact importer'),
    'file' => 'contact_importer.admin.inc',
    'weight' => -1,
    'type' => MENU_LOCAL_TASK,
  );
   $items['admin/settings/contact_importer/providers'] = array(
    'title' => 'Providers and Engines',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('contact_importer_providers_form'),
    'access arguments' => array('administer contact importer'),
    'file' => 'contact_importer.admin.inc',
    'type' => MENU_LOCAL_TASK,
  );
  $items['admin/reports/contact_importer'] = array(
    'title' => 'Contact Importer Log',
    'page callback' => 'contact_importer_log',
    'access arguments' => array('administer contact importer'),
    'file' => 'contact_importer.admin.inc',
  );
  $items['admin/reports/contact_importer/log'] = array(
    'title' => 'Log',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -1,
  );
  $items['admin/reports/contact_importer/clear'] = array(
    'title' => 'Clear logs',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('contact_importer_log_clear_confirm_form'),
    'access arguments' => array('administer contact importer'),
    'file' => 'contact_importer.admin.inc',
    'type' => MENU_LOCAL_TASK,
  );

  // Front end.
  $items['contact_importer'] = array(
    'title' => 'Import your contacts',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('contact_importer_form'),
    'access arguments' => array('access contact importer'),
    'type' => MENU_CALLBACK,
  );
  $items['contact_importer_js'] = array(
    'title' => 'Import your contacts',
    'page callback' => 'contact_importer_js',
    'access arguments' => array('access contact importer'),
    'type' => MENU_CALLBACK,
  );
  $items['contact_importer_js_submit'] = array(
    'title' => 'Import your contacts',
    'page callback' => 'contact_importer_js_submit',
    'access arguments' => array('access contact importer'),
    'type' => MENU_CALLBACK,
  );
  return $items;
}

/**
 * Implementation of hook_requirements().
 *
 * This is in the module file and not the install file because we call it often to see if the module
 * is correctly configured. 
 */
function contact_importer_requirements($phase) {
  $requirements = array();

  // These constants are defined in install.inc which we haven't

  if ($phase == 'runtime') {

    $engines = _contact_importer_engines();

    // Raise an error if there are no engines.
    if (!count($engines)) {
       $requirements['contact_importer_engines'] = array(
        'title' => 'Contact Importer Engines',
        'description' => t(
          'No retrieval engine modules have been enabled.  Please navigate to the '.
          '<a href="@modules">modules page</a> to enable one.',
          array('@modules' => url('admin/build/modules'))
        ),
        'severity' => REQUIREMENT_ERROR,
        'value' => t('No engines found'),
      );
    }

    // Raise an error if an engine's include files do not exist.
    foreach ($engines as $engine_name => $engine) {
      if (!contact_importer_load_library($engine_name)) {
        $requirements['contact_importer_engine_'. $engine_name] = array(
          'title' => 'Contact Importer '. $engine['human_readable'],
          'description' => t(
            '@engine requires one or more library files provided by the retrieval service.  '.
            'These files should be placed at %libraries_path or %module_path. If you are not using '.
            'this retrieval service you must disable the @engine Engine module.',
            array(
              '@engine' => $engine['human_readable'],
              '%libraries_path' => 'sites/all/libraries/'. $engine['library_directory'],
              '%module_path' => drupal_get_path('module', $engine_name) . $engine['library_directory'],
            )
          ),
          'severity' => REQUIREMENT_ERROR,
          'value' => t('Library files not found'),
        );
      }
    }

    // Do we have a modal pop-up?
    if (variable_get('contact_importer_modal', 'none') == 'none') {
      $requirements['contact_importer_modal'] = array(
        'title' => 'Contact Importer modal pop-ups',
        'description' => t('Contact Importer works best when using a '.
          '<a href="@url">modal pop-up</a> to fetch contacts.',
          array('@url' => url('admin/settings/contact_importer/settings'))
        ),
        'severity' => REQUIREMENT_INFO,
        'value' => t('Modal pop-up not found'),
      );
    }

    // Check that there's at least one provider enabled.
    $enabled_providers = _contact_importer_providers_enabled();
    if (!count($enabled_providers)) {
      $requirements['contact_importer_providers_enabled'] = array(
        'title' => 'Contact Importer Providers',
        'severity' => REQUIREMENT_ERROR,
        'value' => t('No providers enabled'),
        'description' => t(
          'No providers have been enabled.  Please navigate to the '.
          '<a href="@providers">providers page</a> to enable one.',
          array('@providers' => url('admin/settings/contact_importer/providers'))
        ),
      );
    }

    // Else all is well.
    if (empty($requirements)) {
      $requirements['contact_importer'] = array(
        'title' => 'Contact Importer',
        'value' => 'Setup correctly',
      );
    }

  }

  return $requirements;
}

/**
 * Implementation of hook_cron().
 */
function contact_importer_cron() {
  // User's that attempt an import, but then bail will have incomplete log entries.
  // Clean these up by marking as complete any session IDs that no longer exist.
  db_query('UPDATE {contact_importer_log} l
    LEFT JOIN {sessions} s
      ON l.session_id = s.sid
    SET l.completed = 1
    WHERE s.sid IS NULL');

  // Cleanup old values from the log table.
  $max = db_result(db_query('SELECT MAX(log_id) FROM {contact_importer_log}'));
  db_query('DELETE FROM {contact_importer_log} WHERE log_id <= %d',
    $max - variable_get('dblog_row_limit', 1000));

}

/**
 * @category CALLBACKS
 */

/**
 * Fetches the form from the Retrieval Engine or confirmation form.
 *
 * @todo this isn't an implementation of hook_form, so we should change the name. Engines too.
 * 
 * @param boolean $js_modal = FALSE
 *  Is the form being used as a javascript modal popup?
 */
function contact_importer_form(&$form_state, $js_modal = FALSE) {

  // Disable admin_menu if present.
  if (
    ($js_modal || !empty($form_state['storage']['js_modal'])) &&
    function_exists('admin_menu_suppress')
  ) {
    admin_menu_suppress();
  }

  // This is a four-step form:
  // 1) The user chooses a provider (select_provider).
  $form = array();
  if (empty($form_state['storage']['step']) || $form_state['storage']['step'] == 'select_provider') {

    // Step one, show the list of providers.
    $form_state['storage']['step'] = 'select_provider';

    // Sanity checking.
    if (_contact_importer_are_requirements_missing()) {
      return drupal_access_denied();
    }

    // Remove any emails stored from a previous attempt.
    contact_importer_set_contacts(NULL);

    // Build the form.
    $form_state['storage']['js_modal'] = $js_modal;
    $form_state['storage']['providers'] = _contact_importer_providers_enabled();
    $form = contact_importer_select_provider_form($form_state);

  }

  // 2) The user enters credentials (credentials).
  elseif ($form_state['storage']['step'] == 'credentials') {
    
    // Build the form.
    $engine_form_function = $form_state['storage']['provider']['engine_enabled'] .'_form';
    if (!function_exists($engine_form_function)) {
      return drupal_not_found();
    }
    $form = $engine_form_function($form_state);
    $form['#attributes']['autocomplete'] = 'off';

    // This step can take a loooong time.  Make sure the user can't re-click the button.
    // We can't use drupal_add_js() due to the form cache.
    $form['#suffix'] = (isset($form['#suffix']) ? $form['#suffix'] : '') . <<<EOD
      <script type="text/javascript">
        <!--//--><![CDATA[//><!--
          $(window).load(function(){
            $("#contact-importer-form").submit(function() {
              $("#edit-submit", "#contact-importer-form").after('<p class="loading">Please wait&hellip;</p>').hide();
              $('body').css('cursor', 'wait');
            });
          });
        //--><!]]>
      </script>
EOD;
    
  }

  // 3) The user selects which contacts to work with (select_contacts).
  elseif ($form_state['storage']['step'] == 'select_contacts') {
    $form = contact_importer_select_contacts_form($form_state);
  }

  // 4) The form is closed and data is passed back to the parent window (close).
  else {

    // Lightbox2 requires us to do some JS trickery.
    // ModalFrame is much smarter and handles this on form submit.
    if (variable_get('contact_importer_modal', 'none') == 'lightbox2') {
      // Return the emails to the parent window.
      // This only gets called when js_modal is true (otherwise things end in the submit handler).
      $emails = contact_importer_get_contacts('string_emails', 'default', TRUE);

      $js = 'window.parent.Drupal.contact_importer.contactImporterFillEmails("'. $emails .'");'.
        'window.parent.Lightbox.end("forceClose");';
      drupal_add_js($js, 'inline', 'footer');
    }
  }

  return $form;
}

/**
 * Validation handler.
 */
function contact_importer_form_validate($form, &$form_state) {
  // Disable admin_menu if present.
  if (!empty($form_state['storage']['js_modal']) && function_exists('admin_menu_suppress')) {
    admin_menu_suppress();
  }

  switch ($form_state['storage']['step']) {
    case 'select_provider':
      break;
    case 'credentials':
      $engine_validation_function = $form_state['storage']['provider']['engine_enabled'] .'_form_validate';
      if (function_exists($engine_validation_function)) {
        $engine_validation_function($form, $form_state);
      }
      break;
  } 
}

/**
 * Submit handler
 */
function contact_importer_form_submit($form, &$form_state) {
  // Disable admin_menu if present.
  if (!empty($form_state['storage']['js_modal']) && function_exists('admin_menu_suppress')) {
    admin_menu_suppress();
  }

  switch ($form_state['storage']['step']) {
    case 'select_provider':
       contact_importer_select_provider_form_submit($form, $form_state);
       $form_state['storage']['step'] = 'credentials';
      break;
    case 'credentials':
      $engine_submit_function = $form_state['storage']['provider']['engine_enabled'] .'_form_submit';
      if (function_exists($engine_submit_function)) {
        $engine_submit_function($form, $form_state);
      }
      $form_state['storage']['step'] = 'select_contacts';
      $form_state['storage']['email'] = 
        isset($form_state['values']['email']) ? $form_state['values']['email'] : '';
      break;
    case 'select_contacts':
      contact_importer_select_contacts_form_submit($form, $form_state);
      $form_state['storage']['step'] = 'close';

      // Log the import as completed.
      $log = array(
        'session_id' => session_id(),
        'email' => $form_state['storage']['email'],
        'authentication_success' => TRUE,
        'completed' => TRUE,
      );
      drupal_write_record('contact_importer_log', $log, array('session_id', 'email', 'authentication_success'));

      // If we are on the non-JS form, return to the calling form.
      // Otherwise don't do anything and the form builder will take care of things.
      // (submit-like code is there and not here because we cannot manipulate the page during the
      // submit handler).
      // Do not unset($_SESSION['contact_importer_destination']) since this is used in other places
      // for sanity checking.
      if (!$form_state['storage']['js_modal']) {
        unset($form_state['storage']);
        $form_state['redirect'] = array($_SESSION['contact_importer_destination'], $_SESSION['contact_importer_destination_query']);
      }
      break;
  }
}

/**
 * Step 1) The select_provider form.
 */
function contact_importer_select_provider_form(&$form_state) {
  $form = array();
  foreach ($form_state['storage']['providers'] as $provider_name => $provider) {
    $favicon = !empty($provider['favicon']) ? $provider['favicon'] : '';
    $form[$provider['type']][$provider_name] = array(
      '#type' => 'submit',
      '#value' => $provider['human_readable'],
      '#prefix' => '<div class="contact-importer-button-wrapper">',
      '#suffix' => $favicon .'</div>',
      '#attributes' => array('style' => 'width:10em; margin:0.5em'),
      // We need some way of identifying the button in the submit handler.
      '#provider_name' => $provider_name,
    );
  }
  foreach ($form as $type => &$fieldset) {
    $fieldset['#type'] = 'fieldset';
    $fieldset['#title'] = ucfirst($type);
  }
  $form['#prefix'] = t('Please choose where to import your contacts from:');
  return $form;
}

function contact_importer_select_provider_form_submit($form, &$form_state) {
  $provider_name = $form_state['clicked_button']['#provider_name'];
  $form_state['storage']['provider'] = $form_state['storage']['providers'][$provider_name];
  $form_state['storage']['provider']['provider_name'] = $provider_name;
  return;
}

/**
 * Step 3) The select_contacts form.
 */
function contact_importer_select_contacts_form(&$form_state) {

  // Log the number of contacts that were retrieved from the provider.
  $log = array(
    'session_id' => session_id(),
    'email' => $form_state['storage']['email'],
    'authentication_success' => TRUE,
    'completed' => FALSE,
    'contacts_retrieved' => count($form_state['storage']['contacts']),
  );
  drupal_write_record('contact_importer_log', $log, 
    array('session_id', 'email', 'authentication_success', 'completed'));

  if (!count($form_state['storage']['contacts'])) {
    unset($form_state['storage']);
    drupal_set_message(t('No contacts could be retrieved from your account.
      Please try again with a different provider.'), 'error');
    drupal_goto(contact_importer_form_url(NULL, $form_state));
  }

  // Create the form.
  $email_list = array();
  $email_list['select_all'] = '<em>'. t('Select/Deselect All') .'</em>';
  foreach ($form_state['storage']['contacts'] as $contact) {
    $name = $contact['name'];
    $email = $contact['email'];
    $email_list[check_plain($email)] = check_plain($name) .' &lt;'. check_plain($email) .'&gt;';
  }
  
  $form['confirmed_list'] = array(
    '#type' => 'checkboxes',
    '#options' => $email_list,    
    '#required' => TRUE,
  );
  $form['add_contact'] = array(
    '#type' => 'submit',
    '#value' => 'Add Contacts',
  );
  
  // Pass the original contact list along so that it can be used
  // by the contact_importer_contacts hook.
  $form['contacts'] = array(
    '#type' => 'value',
    '#value' => $form_state['storage']['contacts'],
  );

  // Select all / deselect all JS.
  $js = <<<EOD
    $(document).ready(function(){
      $('#edit-confirmed-list-select-all').click(function() {
        var checked_status = this.checked;
        $("#contact-importer-form input").each(function() {
          this.checked = checked_status;
        });
      });
      $('#contact-importer-form input').not('#edit-confirmed-list-select-all').click(function() {
        $('#edit-confirmed-list-select-all').each(function(){
          this.checked = false;
        });
      });
    });
EOD;
  drupal_add_js($js, 'inline', 'footer');
  return $form;
}

/**
 * Submit handler
 */
function contact_importer_select_contacts_form_submit($form, &$form_state) {

  // Remove select_all if it is set.
  $list = $form_state['values']['confirmed_list'];
  if (isset($list['select_all'])) {
    if ($list['select_all']) {
      foreach ($list as $email => &$contact) {
        $contact = $email;
      }
    }
    unset($list['select_all']);
  }
  $list = array_filter($list);

  // Log the number of contacts that were imported from the provider.
  $log = array(
    'session_id' => session_id(),
    'email' => $form_state['storage']['email'],
    'authentication_success' => TRUE,
    'completed' => FALSE,
    'contacts_imported' => count($list),
  );
  drupal_write_record('contact_importer_log', $log, array('session_id', 'email', 'authentication_success', 'completed'));

  // Call the contact_importer_contacts hook to allow contrib to modify the
  // results getting sent back to the form.
  contact_importer_invoke($list, $form_state['values']['contacts']);

  // Add the results to the session.
  contact_importer_set_contacts($list);

  // Send the information from iframe modalframe to main window
  if (variable_get('contact_importer_modal', 'none') == 'automodal'){
    modalframe_close_dialog($list);
  }
}

/**
 * Invoke hook_contact_importer_contacts().
 *
 * We need to create our own function to do this as module_invoke_all can't
 * pass values by reference.
 *
 * @param $list - An array of email addresses array($email => $email) that have
 *   been selected by the user.
 * @param $imported - An array of (email, name) pairs containing /all/ of the
 *   contacts that were imported from the selected provider (not just the
 *   selected contacts.
 */
function contact_importer_invoke(&$list, $imported) {
  foreach (module_implements('contact_importer_contacts') as $name) {
    $function = $name . '_contact_importer_contacts';
    $function($list, $imported);
  }
}

/**
 * Build the form only for modal.
 *
 * @return string HTML with no sidebars etc.
 */
function contact_importer_js() {
  echo theme('contact_importer_js', drupal_get_form('contact_importer_form', TRUE));
  module_invoke_all('exit');
  exit();
}

/**
 * Adds our special JS.
 *
 * Since we need to maintain degradablity for browsers with no JS, or no modal,
 * we setup the source forms assuming the worst.  This function then adds JS that makes
 * the source form call the modal framework instead of going to a new page.
 *
 * @return NULL
 */
function contact_importer_add_js() {

  // This is the page that we will return to when the form is submitted.
  // Used for our non JS form. 
  $_SESSION['contact_importer_destination'] = $_GET['q'];
  $query = explode('?', request_uri());
  $_SESSION['contact_importer_destination_query'] = isset($query[1]) ? $query[1] : '';
  $separator = variable_get('contact_importer_separator', '\n');

  if (variable_get('contact_importer_modal', 'none') == 'lightbox2') {
    lightbox2_add_files();

    // Add our own JS.
    // Don't use $(document).ready() so that this fires before Lightbox.
    // This way Lightbox will see the rel attr.
    $js = <<<EOD
      $('a.contact-importer-link').attr('href', $('a.contact-importer-link').attr('href') + '_js');
      $('a.contact-importer-link').attr('rel', 'lightframe[|width:550px; height:550px;]');
      $('.contact-importer-review-message').hide('fast');
EOD;
    drupal_add_js($js, 'inline', 'footer');
  }
  elseif (variable_get('contact_importer_modal', 'none') == 'automodal') {
    // To avoid closing the modal on each form step.
    $automodal_settings = array(
      'automodalClose' => FALSE,
    );

    // onSubmit callback function to transfer emails to original form.
    $js = <<<EOD
      Drupal.automodal.onSubmitCallback = {
        croma_ui: function(emails, statusMessages) {
          Drupal.contact_importer.contactImporterFillEmails(emails);
        }
      }
EOD;
    drupal_add_js($js, 'inline', 'footer');

    // Default automodal settings are autoFit On, draggable On, width:600px, height:400px
    // That settings can be overriden using hook_automodal_alter
    automodal_add('a.contact-importer-link', $automodal_settings);
  }
  if (variable_get('contact_importer_modal', 'none') != 'none') {
    $js = <<<EOD
      Drupal.contact_importer = Drupal.contact_importer || {};

      /**
       * Fills the textfield with our addresses.
       *
       * @param mixed emails
       *   Either a string or array of emails.
       */
      Drupal.contact_importer.contactImporterFillEmails = function(emails) {
        var destination = $('.contact-importer-destination').eq(0);
        switch (typeof(emails)) {
          case 'string':
            var destinationText = destination.val();
            destination.val(destinationText + (destinationText ? "$separator" : '') + emails);
            break;
          case 'object':
            $.each(emails, function(index, email){
              var destinationText = destination.val();
              destination.val(destinationText + (destinationText ? "$separator" : '') + email);
            });
            break;
        }
      };
EOD;
    drupal_add_js($js, 'inline', 'footer');
  }
}

/**
 * Stores the given contacts array for later retrieval.
 *
 * @param mixed $contacts
 *  An array of arrays where each secondary array represents a contact
 *  and has keys for email and name.  Or set to NULL to reset the cache.
 * @return NULL
 */
function contact_importer_set_contacts($contacts = array()) {

  // Do we need to reset?
  if ($contacts === NULL || !is_array($contacts)) {
    unset($_SESSION['contact_importer_contacts']);
  }

  // Otherwise store the contacts.
  $_SESSION['contact_importer_contacts'] = $contacts;
}

/**
 * Return the contacts.
 *
 * @param string $format
 *  What format do you want the contacts returned as: 
 *  'array', 'string_emails', 'string_names' 
 * @param string $separator
 *  Only used for formats other than 'array'.  What do you want to separate the elements?
 *  If 'default', the value as saved on the settings form will be used. 
 * @return mixed
 *  If it appears that we are at a new URL, then we must be on a different import form, then the stored
 *    contacts are no longer valid, then NULL is returned.
 *  If the format is 'array' an array of arrays where each secondary array represents a contact
 *    and has keys for email and name.
 *  Otherwise a string.
 */
function contact_importer_get_contacts($format = 'string_emails', $separator = 'default', $js = FALSE) {
  if (isset($_SESSION['contact_importer_contacts'])) {
    $contacts = (array)$_SESSION['contact_importer_contacts'];
  }
  else {
    $contacts = array();
  }

  // Get seperator.
  if ($separator == 'default') {
    $separator = variable_get('contact_importer_separator', '\n');
  }
  if ($js == FALSE) {
    $separator = str_replace(array('\r', '\n'), array("\r", "\n"), $separator);
  }
  
  // Are we on the same form as the original process, or is this a new form?
  if (
    !$js &&
    isset($_SESSION['contact_importer_destination']) &&
    $_SESSION['contact_importer_destination'] == $_GET['q']
    ||
    $js &&
    $_GET['q'] == 'contact_importer_js'
  ) {
    contact_importer_set_contacts(NULL);
    if ($format == 'array') {
      return $contacts;
    }
    if ($format == 'string_names') {
      $contacts = array_flip($contacts);
    }
    return implode($separator, $contacts);
  }
  return NULL;
}

/**
 * Bind Contact Importer to the given field on the given form.
 *
 * @param array &$form
 *  FAPI form array.
 * @param string $field_name
 *  The field to bind to.
 * @return boolean
 *  TRUE on successful binding, else FALSE.
 */
function contact_importer_bind_to_form(&$form, $field_name) {

  // We can only bind to one form per page.
  static $has_run = FALSE;

  if (!$has_run && user_access('access contact importer') &&
    $_GET['q'] != 'contact_importer' && $_GET['q'] != 'contact_importer_js'
  ) {

    // Get a reference to the field if it exists.
    $field_reference =& _contact_importer_find_field($form, $field_name);
    if (empty($field_reference)) {
      return FALSE;
    }

    // When a modal pop-up is used, this class tells Contact Importer to put the email addresses here.
    $class = 'contact-importer-destination';
    if (isset($field_reference['#attributes']['class'])) {
      $field_reference['#attributes']['class'] .= ' '. $class;
    }
    else {
      $field_reference['#attributes']['class'] = $class;
    }

    // If the user has already imported contacts, but they don't have Javascript, they will be
    // redirected back here.
    $field_reference['#default_value'] = contact_importer_get_contacts();

    // Initiate Contact Importer.
    // It is important that this happens after saved contacts are retrieved above.
    contact_importer_add_js();

    // Show the link to import the contacts.
    $description = '<div class="contact-importer-message">'.
      t('You can also <a href=!importer-link class="contact-importer-link">import your '.
        'contacts from GMail, Yahoo!, Lycos, AOL, Hotmail and many more.</a>',
        array('!importer-link' => url('contact_importer'))) .
      '</div>';
    if (isset($field_reference['#description'])) {
      $field_reference['#description'] .= ' '. $description;
    }
    else {
      $field_reference['#description'] = $description;
    }
    
    return $has_run = TRUE;
  }
  return FALSE;
}

/**
 * Returns a wildcard domains array (For providers that work with all domains).
 *
 * @return array
 */
function contact_importer_domains_wildcard_array() {
  return array(
    '*' => array(
      'regex' => '/(.*)/i',
      'human_readable' => '*',
    ),
  );
}

/**
 * Takes a human readable string and makes it machine readable.
 *
 * @param string $human_readable
 * @return string
 */
function contact_importer_string_make_machine_readable($human_readable) {
  return strtolower(preg_replace("/[^A-Za-z0-9+]/", '', $human_readable));
}

/**
 * Clears all of our caches.
 */
function contact_importer_cache_clear_all() {
  cache_clear_all('contact_importer', 'cache', TRUE);
}

/**
 * Loads an engine's required library.
 *
 * @param string $engine_name
 * @param array $engine = NULL
 *  The engine info.  Should be omitted in most cases unless called from an info hook.
 * @return mixed
 *  TRUE on success, or FALSE on error.
 */
function contact_importer_load_library($engine_name, $engine = NULL) {
  if (empty($engine)) {
    $engines = _contact_importer_engines();
    $engine = $engines[$engine_name];
  }

  // Where is the library?
  if (function_exists('libraries_get_path')) {
    $library_path = libraries_get_path($engine['library_directory']) .'/'. $engine['library_filename'];
  }
  elseif (file_exists('./sites/all/libraries/'. $engine['library_directory'])) {
    $library_path = './sites/all/libraries/'. $engine['library_directory'] .'/'.
      $engine['library_filename'];
  }
  elseif (file_exists('./'. drupal_get_path('module', $engine_name) .'/'. $engine['library_directory'])) {
    $library_path = './'. drupal_get_path('module', $engine_name) .'/'. $engine['library_directory'] .'/'.
      $engine['library_filename'];
  }
  
  // Does the file exist?
  if (empty($library_path) || !is_file($library_path)) {
    watchdog('Contact Importer', 'Error loading library.  The library for %engine may be missing.',
      array('%engine' => $engine_name), WATCHDOG_ERROR);
    return FALSE;
  }
  require_once $library_path;
  return TRUE;

}

/**
 * When the user logs in to the provider call this function to create a log entry.
 *
 * @param string $provider_name
 *  The provider used.
 * @param boolean $success
 *  TRUE on successfull login, else FALSE.
 * @param string $email_address = ''
 *  The email address / username used to login.  Leave blank for upload providers.
 */
function contact_importer_log_authentication($provider_name, $engine_name, $success = TRUE, $email = '') {
  $log = array(
    'session_id' => session_id(),
    'provider_name' => $provider_name,
    'engine_name' => $engine_name,
    'authentication_success' => $success,
    'email' => $email,
    'completed' => FALSE,
  );
  drupal_write_record('contact_importer_log', $log);
}

/**
 * @category THEME FUNCTIONS
 */

/**
 * Implementation of hook_theme().
 */
function contact_importer_theme() {
  return array(
    'contact_importer_js' => array(
      'arguments' => array('content'),
    ),
    'contact_importer_providers_form' => array(
      'arguments' => array('form' => NULL),
      'file' => 'contact_importer.admin.inc',
    ),
  );
}

/**
 * Themes the given form in a plain html page.
 */
function theme_contact_importer_js($content) {
  $html = '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" '.
    '"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">' .
    '<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">'."\n<head>\n";
  $html .= "<title>". variable_get('site_name', '') ."</title>\n";
  $html .= drupal_get_html_head();
  $html .= drupal_get_js() ."\n";
  $html .= drupal_get_css() ."\n";
  $html .= '<style>';
  $html .= '#edit-confirmed-list-select-all-wrapper {border-bottom:1px solid;}';
  $html .= 'html {padding: 1em}';
  $html .= '</style>';
  $html .= "</head>\n<body id=\"contact-importer-popup\">\n";
  $html .= '<h2>'. drupal_get_title() .'</h2>';
  $html .= theme('status_messages');
  $html .= theme('help');
  $html .= $content;
  $html .= theme('closure');
  $html .= '</body></html>';
  return $html;
}

/**
 * @category INTERNAL FUNCTIONS
 */

/**
 * Gets a list of compatible retrieval engines.
 *
 * @return array of arrays
 *  Each secondary array represents a retrieval engine with keys for:
 *    human_readable - Name of the library/service that the engine integrates with.
 *    url - URL of library.
 *    inc - The path to the library's main include file, without which the engine cannot function.
 *    readme - The plain-text or HTML documentation for the engine.
 *    providers - an array of providers.  Each provider has keys for:
 *      human_readable - the human readable form of the provider name.
 *      type - one of 'webmail', 'social', or 'upload'.
 *      possible_favicon_urls - An array of URLs that might be favicons in order of preference.
 *        These will then be resolved into
 *          provider['favicon_url'] - the URL of the favicon, if one was found, else ''
 *          provider['favicon'] - an HTML image tag of the favicon, if one was found, else ''
 *      domains - an array of the domains that the provider supports.  Each doamin has keys for:
 *        human_readable - the human readable form of the provider name.
 *        regex - a Perl compatible regular expression that can be used to find the domain.
 *
 *  An engine may add any additional data that it requires.
 *
 *  All of this is cached, so an engine may do any expensive processing that it requires.
 *
 *  Ex.
 *    array(
 *      'foo_engine' => array(
 *        'human_readable' => 'Foo Engine',
 *        'url' => 'http://foo.com',
 *        'inc' => 'foo/foo.php',
 *        'readme' => 'README.txt',
 *        'providers' = array(
 *          'gmail' => array(
 *            'human_readable' => 'GMail',
 *            'type' => 'webmail',
 *            'possible_favicon_urls' => array('http://mail.google.com/favicon.ico'),
 *            'domains' => array(
 *              'gmailcom' => array(
 *                'human_readable' => 'gmail.com',
 *                'regex' => '/(gmail.com)/i',
 *              ),
 *              'googlemailcom' => array(
 *                'human_readable' => 'googlemail.com',
 *                'regex' => '/(googlemail.com)/i',
 *              ),
 *            ),
 *          ),
 *          'thunderbird' => array(
 *            'human_readable' => 'Thunderbird',
 *            'type' => 'upload',
 *            'possible_favicon_urls' => array('http://mxr.mozilla.org/comm-central/source/other-licenses/branding/thunderbird/mailicon16.png?raw=1'),
 *            'domains' => array(
 *              '*' => array(
 *                'human_readable' => '*',
 *                'regex' => '/(.*)/i',
 *              ),
 *            ),
 *          ),
 *          'facebook' => array(
 *            'human_readable' => 'Facebook',
 *            'type' => 'social',
 *            'possible_favicon_urls' => array('http://facebook.com/favicon.ico'),
 *            'domains' => array(
 *              '*' => array(
 *                'human_readable' => '*',
 *                'regex' => '/(.*)/i',
 *              ),
 *            ),
 *          ),
 *        ),
 *      ),
 *    );
 */
function _contact_importer_engines() {
  static $engines = array();
  if (!empty($engines)) {
    return $engines;
  }

  // Check cache.
  $cache = cache_get('contact_importer_engines');
  if (!empty($cache->data)) {
    return $cache->data;
  }

  // Invoke engines.
  foreach (module_implements('retrieval_engine_info') as $module) {
    $engines[$module] = module_invoke($module, 'retrieval_engine_info');
  }
  
  // Save to cache.
  if (!empty($engines)) {
    ksort($engines);
    cache_set('contact_importer_engines', $engines);
  }
  return $engines;
}

/**
 * Gets a list of all providers.
 *
 * @return array of arrays
 *  Each secondary array is a provider.
 * @see _contact_importer_engines
 *  Additionally each provider also has a keys for
 *    engines - an array of the engines that work with this
 *    engine_enabled - the name of the engine that is managing this provider, or NULL if it is
 *      disabled.
 */
function _contact_importer_providers() {
  $providers = array();
  $engines = _contact_importer_engines();
  foreach ($engines as $engine_name => $engine) {
    foreach ($engine['providers'] as $provider_name => $provider) {

      // Add the provider if another engine has not already done so, otherwise add only the domains.
      if (!isset($providers[$provider_name])) {
        $providers[$provider_name] = $provider;
      }
      else {

        // Choose the best favicon.
        if (!empty($providers[$provider_name]['possible_favicon_urls'])) {
          $providers[$provider_name]['possible_favicon_urls'] = array_merge(
            $providers[$provider_name]['possible_favicon_urls'], $provider['possible_favicon_urls']);
        }

        // Merge domains.
        $providers[$provider_name]['domains'] =
          array_merge($providers[$provider_name]['domains'], $provider['domains']);

        // Add any additional data.
        foreach ($provider as $field => $value) {
          if (!isset($providers[$provider_name][$field])) {
            $providers[$provider_name][$field] = $value;
          }
        }

      }
      ksort($providers[$provider_name]['domains']);

      // Add to the engines array.
      $providers[$provider_name]['engines'][$engine_name] = $engine['human_readable'];
    }
  }
  ksort($providers);

  // Add the details on which engine is managing which provider.
  $providers_saved = variable_get('contact_importer_providers_saved', array());
  foreach ($providers as $provider_name => &$provider) {
    $provider['engine_enabled'] =
      !empty($providers_saved[$provider_name]) ? $providers_saved[$provider_name] : NULL;
  }

  return $providers;
}

/**
 * Gets a list of the enabled providers.
 *
 * @return array of arrays
 *  Each secondary array is a provider type.  Each provider type is an array of arrays.  Each
 *  tertiary array represents a provider.
 * @see _contact_importer_engines
 *  Each provider also has a key for 'engine_enabled' which is the name of the engine that is managing this
 *  provider.
 */
function _contact_importer_providers_enabled() {
  static $providers = array();
  if (!empty($providers)) {
    return $providers;
  }

  // Check cache.
  $cache = cache_get('contact_importer_providers');
  if (!empty($cache->data)) {
    return $cache->data;
  }

  $providers = _contact_importer_providers();
  foreach ($providers as $provider_name => &$provider) {
    if (empty($provider['engine_enabled'])) {
      unset($providers[$provider_name]);
      continue;
    }

    // Resolve favicons.
    // TODO: This could be done with a shutdown function to prevent the long page load.
    foreach ($provider['possible_favicon_urls'] as $favicon_url) {
      if ($image = _contact_importer_is_url_an_image($favicon_url)) {
        $provider['favicon_url'] = $favicon_url;
        $local_url = _contact_importer_save_data_locally($image, $provider_name .'_favicon.ico');
        if ($local_url) {
          $provider['favicon_url'] = $local_url;
        }
        $provider['favicon'] = theme('image', $provider['favicon_url'], '',
          $provider['human_readable'], array('height' => '16px', 'width' => '16px'), FALSE);
        unset($provider['possible_favicon_urls']);
        continue(2);
      }
    }
    unset($provider['possible_favicon_urls']);
    $provider['favicon_url'] = $provider['favicon'] = '';
  }

  // Save to cache.
  if (!empty($providers)) {
    cache_set('contact_importer_providers', $providers);
  }
  return $providers;
}

/**
 * Return a reference to the given field of the form.  Even works for a field within a fieldset.
 *
 * Note that to get a reference to a field you would do
 * $field_reference =& _contact_importer_find_field($form, $field);
 * 
 * @param array $form
 *  FAPI form array.
 * @param string $field
 *  The field to search for. 
 */
function &_contact_importer_find_field(&$form, $field) {
  $empty = array();
  if (isset($form[$field])) {
    return $form[$field];
  }
  $children = element_children($form);
  foreach ($children as $child) {
    if (empty($form[$child]['#type']) || $form[$child]['#type'] == 'fieldset') {
      $field_reference =& _contact_importer_find_field($form[$child], $field);
      if (!empty($field_reference)) {
        return $field_reference;
      }
    }
  }
  return $empty;
}

/**
 * Check to see if the module is missing any requirements.
 *
 * @param boolean $check_errors_and_warnings
 *  Check for error and warning level messages.
 * @param boolean $check_info
 *  Check for information level messages.
 * @return boolean
 *  TRUE if something still needs to be configured, else FALSE.
 */
function _contact_importer_are_requirements_missing($check_errors_and_warnings = TRUE, $check_info = FALSE) {
  
  // We need to include this because the REQUEIREMENT_* constants are defined there.
  include_once './includes/install.inc';

  $requirements = contact_importer_requirements('runtime');
  foreach ($requirements as $requirement) {
    if (!empty($requirement['severity'])) {
      if ($requirement['severity'] == REQUIREMENT_INFO) {
        if ($check_info) {
          return TRUE;
        }
      }
      elseif ($check_errors_and_warnings) {
        return TRUE;
      }
    }
  }
  return FALSE;
}

/**
 * Tests if the URL is likely to point to an image.  Not 100% accurate.
 *
 * @param string $url
 * @return mixed
 *  The image data if the URL points to an image, else FALSE.
 */
function _contact_importer_is_url_an_image($url) {
  $response = drupal_http_request($url);
  if (
    $response->code == 200 || $response->code == 301 &&
    isset($response->headers['Content-Type']) &&
    strpos(strtolower($response->headers['Content-Type']), 'image') !== FALSE &&
    !empty($response->data)
  ) {
    return $response->data;
  }
  return FALSE;
}

/**
 * Save a remote file on the local filesystem.
 *
 * @param string $data
 *  The contents of the file.
 * @param string $filename
 *  The name to save it to.  It is the callers responsibility to ensure that this file has a safe
 *  extension (i.e. no PHP files).
 * @return mixed
 *  the path of the local file (relative to the Drupal files directory). Or 0 on error.
 */
function _contact_importer_save_data_locally($data, $filename) {
  $directory = file_create_path('contact_importer');
  if (!file_check_directory($directory, FILE_CREATE_DIRECTORY)) {
    return 0;
  }
  $filename = $directory .'/'. $filename;
  return file_save_data($data, $filename, FILE_EXISTS_REPLACE);
}

/**
 * Determine the URL to use for the main contact importer form.
 * Used if there's an error partway through the multistep form and we need to return to the beginning.
 *
 * @param array $form_state = NULL
 *  The FAPI form_state array if available.
 *
 * @return string
 */
function contact_importer_form_url($form_state = NULL) {
  $url = url('contact_importer');
  if (isset($form_state['storage']['js_modal'])) {
    $url = 'contact_importer'. ($form_state['storage']['js_modal'] ? '_js' : '');
  }
  elseif (arg(0) == 'contact_importer') {
    $url = 'contact_importer';
  }
  elseif (arg(0) == 'contact_importer_js') {
    $url = 'contact_importer_js';
  }
  elseif (variable_get('contact_importer_modal', 'none') == 'lightbox2') {
    $url = 'contact_importer_js';
  }
  $url = url($url);

  // Can't get automodal to revert properly.  Gotta bail.
  // Neither history.go() or window.location.href will work for us.
  if (variable_get('contact_importer_modal', 'none') == 'automodal') {
    $js = <<<EOD
      $(window).load(function(){
        $('a[href="$url"]').click(function(event){
          event.preventDefault();
          window.parent.Drupal.modalFrame.close();
        });
      });
EOD;
    drupal_add_js($js, 'inline', 'footer');
  }
  return $url;
}
