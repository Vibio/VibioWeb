<?php
define("NETWORK_DEFAULT_DEPTH", 1);

function network_menu()
{
	return array(
		"contacts/find-friends"	=> array( // s /network/contact 20110926
			"title"				=> "Connection Finder",
			"title callback"  => "connection_finder_title",
			"page callback"		=> "network_find_friends",
			"access arguments"	=> array("can have relationships"),
			"file"				=> "network.pages.inc",
			"type"				=> MENU_LOCAL_TASK,  // MENU_CALLBACK,
			"weight" => 1,
		),
	);
}
function connection_finder_title() {   /* otherwise parent overrides? */
	// use drupal_set_message in the page.inc, not sure why this here doesn't
	// work.  bad bad bad !!!
  return t("Connection Finder");
}

function network_theme()
{
	return array(
		"network_potential_friend" => array(
			"arguments"	=> array("friend" => false, "photo" => "", "uri_links" => ""),
			"template"	=> "templates/network/potential-friend",
			"path"		=> drupal_get_path("theme", "vibio"),
		),
		"network_potential_friends"=> array(
			"arguments"	=> array("friends_list" => ""),
			"template"	=> "templates/network/potential-friends",
			"path"		=> drupal_get_path("theme", "vibio"),
		),
		"network_friend_finder_messages" => array(
			"arguments"	=> array("errors" => ""),
			"template"	=> "templates/network/friend-finder-messages",
			"path"		=> drupal_geT_path("theme", "vibio"),
		),
	);
}

/**
 * note that this returns a user's network in a flat format. it's up to the consumer of this
 * function to manipulate the data into a useful format (degree of separation format may not
 * necessarily be ideal for other applications). However, this function WILL return the friends
 * for each user in the target user's network, so putting the data into a useful format shouldn't
 * be too hard.
 *
 * $rel_type --> integer, relatonship type of the connection
 * $depth    --> integer, ho many levels the network should be traced
*/
function network_get($uid, $rel_type=false, $depth=false)
{
  global $user;

  //Diana is exceeding memory limits because her network is huge (she's
  //a default friend to everyone). Set her depth to 1.
  if($user->name == "Diana Bull"){
    return '';
  }
  
	static $networks = array();
	
    $rel_type = $rel_type ? $rel_type : 1;

    //If the network is already defined, use that.	
	if (isset($networks[$uid][$rel_type][$depth]))
	{
		return $networks[$uid][$rel_type][$depth];
	}

	if (!$depth)
	{
		$depth = NETWORK_DEFAULT_DEPTH;
	}
	
	$user_queue = array($uid);
	$network = array();
	$current_depth = 0;
	//generate $network, starting wit the $uid user
	while (!empty($user_queue) && $current_depth <= $depth)
	{
		$next_queue = array();
		//Populate the $network for every user in $user_queue 
		foreach ($user_queue as $q_uid)
        {
            //Populate data about the current user in the queue
			if (!array_key_exists($q_uid, $network))
			{
        //If the current user in the queue is Diana, don't load her network 
        //@todo: get rid of this hack
        $network[$q_uid] = _network_get_userinfo($q_uid);
        if($network[$q_uid]['name'] != 'Diana Bull'){
          $network[$q_uid]['friends'] = _network_get_friends($q_uid, $rel_type);
        }else{
          $network[$q_uid]['friends'] = array();
        }
			}
            //Place the current user's friends next i the queue
            foreach ($network[$q_uid]['friends'] as $friend_id)
			{
				$next_queue[] = $friend_id;
			}
		}
	    //Increase the depth and rotate the queue	
		++$current_depth;
		$user_queue = $next_queue;
	}
	
	$networks[$uid][$rel_type][$depth] = $network;
	
	return $network;
}

function network_user_relationships($op, &$rel)
{
	switch ($op)
	{
		case "approve":
		case "remove":
			cache_clear_all("friends:{$rel->requester_id}", "cache_network", true);
			cache_clear_all("friends:{$rel->requestee_id}", "cache_network", true);
			break;
	}
}

function network_preprocess_uri_user_friends(&$vars)
{
	drupal_add_css("themes/vibio/css/network.css");
}

function network_fb_link_account($user, $is_signup)
{
	cache_clear_all("userinfo:{$user->uid}", "cache_network");
}

function network_ebay_add_account($uid)
{
	cache_clear_all("userinfo:$uid", "cache_network");
}

function network_ebay_remove_account($uid)
{
	cache_clear_all("userinfo:$uid", "cache_network");
}

/**
 * Gets the uids of $uid's existing friends on the vibio network
 * @todo: replace w/User Relationshp function if needed elsewhere
 * @todo: refactor to use caching more intelligently for users
 *        with very large networks; Diana (default friend) was causing
 *        huge performance issues, probably because her network was
 *        being continually refreshed? Needs more investigation...
 *
 * @param <type> $uid
 * @param <type> $rel_type
 * @return Array Friend uids
 */
function _network_get_friends($uid, $rel_type)
{
    //See if we can retrieve cache
    $cache_key = "friends:{$uid}:{$rel_type}";
	if ($cache = cache_get($cache_key, "cache_network"))
    {
        //If so, return the cache and exit
        return $cache->data;
    }

    //If not, start constructing the network array
	$params = array(
		"user"		=> $uid,
		"approved"	=> 1,
	);
	$options = array(
        "include_user_info"	=> TRUE,
	);
	
	$friends = array();

    //Load the related users
    foreach (user_relationships_load($params, $options) as $rel)
	{
        //Insert friend uids, make sure we aren't entering the user's $uid 
        if ($rel->requester_id != $uid)
        {
            $friends[] = $rel->requester_id;
		}
		elseif ($rel->requestee_id != $uid)
		{
			$friends[] = $rel->requestee_id;
		}
	}
    //Set the cache
    cache_set($cache_key, $friends, "cache_network");
    
    return $friends;
}

/**
 * Collates user data. Defines hook_network_get_user_info.
 *
 * Grabs username from the user table and any other data you want it
 * to grab as long as you implement the hook.
 *
 * @param <type> $uid
 * @param <type> $info
 * @param <type> $reset
 * @return <type>
 */
function _network_get_userinfo($uid, $info=false, $reset=false)
{
	$cache_key = "userinfo:{$uid}";
	if (!$reset && $cache = cache_get($cache_key, "cache_network"))
	{
		return $cache->data;
	}
	
	if (!$info)
	{
		$sql = "SELECT `name`
				FROM {users}
				WHERE `uid`=%d";
		$info = db_fetch_object(db_query($sql, $uid));
	}
	
	$basic = array(
		"name"	=> $info->name,
	);
	
	$data = array_merge($basic, module_invoke_all("network_get_userinfo", $uid));
	cache_set($cache_key, $data, "cache_network");
	
	return $data;
}
?>
