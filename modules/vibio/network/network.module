<?php
define("NETWORK_DEFAULT_DEPTH", 3);

function network_menu()
{
	return array(
		"contacts/find-friends"	=> array( // s /network/contact 20110926
			"title"				=> "Connection Finder",
			"title callback"  => "connection_finder_title",
			"page callback"		=> "network_find_friends",
			"access arguments"	=> array("can have relationships"),
			"file"				=> "network.pages.inc",
			"type"				=> MENU_LOCAL_TASK,  // MENU_CALLBACK,
			"weight" => 1,
		),
	);
}
function connection_finder_title() {   /* otherwise parent overrides? */
	// use drupal_set_message in the page.inc, not sure why this here doesn't
	// work.  bad bad bad !!!
  return t("Connection Finder");
}

function network_theme()
{
	return array(
		"network_potential_friend" => array(
			"arguments"	=> array("friend" => false, "photo" => "", "uri_links" => ""),
			"template"	=> "templates/network/potential-friend",
			"path"		=> drupal_get_path("theme", "vibio"),
		),
		"network_potential_friends"=> array(
			"arguments"	=> array("friends_list" => ""),
			"template"	=> "templates/network/potential-friends",
			"path"		=> drupal_get_path("theme", "vibio"),
		),
		"network_friend_finder_messages" => array(
			"arguments"	=> array("errors" => ""),
			"template"	=> "templates/network/friend-finder-messages",
			"path"		=> drupal_geT_path("theme", "vibio"),
		),
	);
}

/**
 * note that this returns a user's network in a flat format. it's up to the consumer of this
 * function to manipulate the data into a useful format (degree of separation format may not
 * necessarily be ideal for other applications). However, this function WILL return the friends
 * for each user in the target user's network, so putting the data into a useful format shouldn't
 * be too hard.
*/
function network_get($uid, $rel_type=false, $depth=false)
{
	static $networks = array();
	
	$rel_type = $rel_type ? $rel_type : 1;
	
	if (isset($networks[$uid][$rel_type][$depth]))
	{
		return $networks[$uid][$rel_type][$depth];
	}
	
	if (!$depth)
	{
		$depth = NETWORK_DEFAULT_DEPTH;
	}
	
	$user_queue = array($uid);
	$network = array();
	$current_depth = 0;
	
	while (!empty($user_queue) && $current_depth <= $depth)
	{
		$next_queue = array();
		
		foreach ($user_queue as $q_uid)
		{
			if (!array_key_exists($q_uid, $network))
			{
				$network[$q_uid] = _network_get_userinfo($q_uid);
				$network[$q_uid]['friends'] = _network_get_friends($q_uid, $rel_type);
			}
			
			foreach ($network[$q_uid]['friends'] as $friend_id)
			{
				$next_queue[] = $friend_id;
			}
		}
		
		++$current_depth;
		$user_queue = $next_queue;
	}
	
	$networks[$uid][$rel_type][$depth] = $network;
	
	return $network;
}

function network_user_relationships($op, &$rel)
{
	switch ($op)
	{
		case "approve":
		case "remove":
			cache_clear_all("friends:{$rel->requester_id}", "cache_network", true);
			cache_clear_all("friends:{$rel->requestee_id}", "cache_network", true);
			break;
	}
}

function network_preprocess_uri_user_friends(&$vars)
{
	drupal_add_css("themes/vibio/css/network.css");
}

function network_fb_link_account($user, $is_signup)
{
	cache_clear_all("userinfo:{$user->uid}", "cache_network");
}

function network_ebay_add_account($uid)
{
	cache_clear_all("userinfo:$uid", "cache_network");
}

function network_ebay_remove_account($uid)
{
	cache_clear_all("userinfo:$uid", "cache_network");
}

/**
 * Gets the uids of $uid's existing friends on the vibio network
 * @todo: replace w/User Relationshp function if needed elsewhere
 * @todo: 
 *
 * @param <type> $uid
 * @param <type> $rel_type
 * @return Array Friend uids
 */
function _network_get_friends($uid, $rel_type)
{
	$cache_key = "friends:{$uid}:{$rel_type}";
	if ($cache = cache_get($cache_key, "cache_network"))
	{
		return $cache->data;
	}

	$params = array(
		"user"		=> $uid,
		"approved"	=> 1,
	);
	$options = array(
		"include_user_info"	=> true,
	);
	
	$friends = array();
	foreach (user_relationships_load($params, $options) as $rel)
	{
		if ($rel->requester_id != $uid)
		{
			$friends[] = $rel->requester_id;
		}
		elseif ($rel->requestee_id != $uid)
		{
			$friends[] = $rel->requestee_id;
		}
	}
	
	cache_set($cache_key, $friends, "cache_network");
	return $friends;
}

function _network_get_userinfo($uid, $info=false, $reset=false)
{
	$cache_key = "userinfo:{$uid}";
	if (!$reset && $cache = cache_get($cache_key, "cache_network"))
	{
		return $cache->data;
	}
	
	if (!$info)
	{
		$sql = "SELECT `name`
				FROM {users}
				WHERE `uid`=%d";
		$info = db_fetch_object(db_query($sql, $uid));
	}
	
	$basic = array(
		"name"	=> $info->name,
	);
	
	$data = array_merge($basic, module_invoke_all("network_get_userinfo", $uid));
	cache_set($cache_key, $data, "cache_network");
	
	return $data;
}
?>
